from concurrent.futures import ThreadPoolExecutor
from multiprocessing import Pool

import pexpect
import requests
import signal

from config import Config
from util import *


def _exploit(exploit, target):
    # Spawn the exploit
    p = pexpect.spawn(exploit)

    # Kill the spawned exploit on timeout
    signal.signal(signal.SIGALRM, lambda sig, frame: p.terminate())

    # After the specified seconds the exploit will be killed
    signal.alarm(Config.Exploiter.timeout)

    # Read the exploit output and get flags
    while p.isalive():
        flag = p.readline().decode().strip()
        if flag != '':

            # We use this loop to prevent flags not being submitted and stored in the database
            # there is probably a nicer way to do this with requests timeouts and/or retries.
            sent = False
            while not sent:
                try:
                    requests.post(Config.Backend.WebService.url_submit, data={'flag': flag, 'exploit': exploit, 'target': target})
                    sent = True
                except:
                    pass

    # Disable the alarm
    signal.alarm(0)


# Default exploiter class
# Uses multiprocessing (should bypass GIL restrictions)
class Exploiter:

    @staticmethod
    def start():
        pool = Pool(Config.Exploiter.PoolSize)
        exploits = get_exploits()
        targets = get_targets()
        for exploit in exploits:
            for target in targets:
                pool.apply_async(_exploit, (exploit, target))
        # Prevents any more tasks from being submitted to the pool.
        # Once all the tasks have been completed the worker processes will exit.
        pool.close()


# Alternative exploiter class
# Uses ThreadPoolExecutor (threading library)
class ExploiterThread:

    @staticmethod
    def start():
        executor = ThreadPoolExecutor(Config.Exploiter.PoolSize)
        exploits = get_exploits()
        targets = get_targets()

        for exploit in exploits:
            for target in targets:
                executor.submit(_exploit, exploit, target)


if __name__ == '__main__':
    Exploiter.start()
